1.线程池的属性是可以在运行时修改的。可以结合nacos的配置中心，来动态修改配置
2.如何优雅的关闭一个线程？
    thread.stop()可以关闭线程，但是太简单粗暴了，而且只会释放synchronize加的锁，lock的锁是不会释放的。
    正确的关闭线程的方法应该调用thread.interrupt();
3.synchronized锁升级
    jdk1.6之前 synchronized都是重量级锁（会调用操作系统的api,同时会阻塞）,1.6之后引入了偏向锁、轻量锁

4.JVM内存模型及加载机制
    栈区
    堆区
    元数据区(方法区)  jdk1.8之前是叫“方法区”,他是堆内存里一块连续的内存区域，1.8之后就是堆外的一块区域(操作系统中?)，叫"元数据区“,存放类信息和常量信息

5.jvm垃圾回收算法和垃圾回收器
    0)判断一个对象是否是垃圾的方法
        <1>引用计数器(早期) 会有循环引用问题
        <2>根可达性分析
    1）垃圾回收算法
        <1>标记清除算法: 标记需要回收的垃圾，然后清除。 缺点：内存碎片化
        <2>拷贝算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存需要进行垃圾回收时，
                   会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。 浪费内存
        <3>标记整理法：标记过程仍与 " 标记 - 清除 " 过程一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，
                     然后直接清理掉端边界以外的内存。
        <4>分代算法：
    2）垃圾回收器：
        <1>serial串行回收器(新老年代)。 用户线程执行————>(STW)单个GC线程垃圾回收————>用户线程————>(STW)单个GC线程
        <2>parallel并行回收器(新老年代)。用户线程执行————>(STW)多个GC线程垃圾回收————>用户线程————>(STW)多个GC线程
        <3>CMS 并行标记清除回收器。用户线程执行————>(STW)GC线程初步标记垃圾————>用户线程,GC线程并发标记————>(STW)GC线程重新标记
                               ————>用户线程,GC线程并发清除(此时用户线程产生的浮动垃圾由下次GC标记)
        <4>G1垃圾优先回收器。  此回收器不分代

6.Minor GC、 Major GC、Full GC 的关系：
  1）Minor GC 又称为新生代GC：指的是发生在新生代的垃圾回收。因为Java对象大多都具备朝生夕灭的特性，因此Minor GC（采用的是复制算法）非常频繁，
    一般回收速度也比较的块。
  2）Major GC 又称为老年代GC，一般的老年代GC，总是由于某次Minor GC 引起的，所以 Major GC 发生的时候也是 Full GC,可以看作他两个等效。

7.RSA非对称加密
    A拿B的公钥对传输的数据进行加密，加密后，再拿密文用A的私钥签名，B拿到密文后，用A的公钥验签，验签通过，再用B的私钥解密数据
8.CountDownLatch CylicBarrier Semaphore的用法：
9.ForkJoinPool的使用
10.同步、异步、阻塞、非阻塞的区别：
    0)注： 只有同步阻塞、同步非阻塞、异步非阻塞。只要是异步了就一定是非阻塞，没有异步阻塞
    1）同步：调用之后，等待结果返回。
    2）异步：调用之后，直接返回。 结果会通过回调等其他机制来处理
    3）阻塞：调用之后，线程会被挂起。
    4）非阻塞：调用之后，线程不会挂起