1.innodb索引B+树
    1）mysql页的概念
        [1]页其实就是一次innodb最小操作单元，每页16KB，每次查询都是一页一页查出来，新增数据也是，一页写满了才会刷到磁盘。（页： 减少磁盘IO）
           每页记录了n条数据,而且数据是排好序的。为了快速查找数据(为了防止数据过多，变成链表遍历)，给页里的数据，分了组。每一组取最小的数据作为目录。
           比如：按主键排序(没有主键会自动创建一个)有1~100000条数据。如果不分组，则要查询id=99999数据，则要遍历到最后。分组后，比如分100组，每组1000条数据，只要遍历目录，
                就能知道99999在哪一组，然后直接遍历最后一组就可以快速找到。但是当一个表数据非常多的时候，他分了几千几万页。如果一页一页遍历查找，也会很慢。所以按照页的思想，
                把再建一个页，把之前的所有页分组，把每一页最小值作为目录。比如：有十页，第一页1~10000 第二页 10001~20000 第十页 90001~100000。在这十页之上建的另一页，
                把刚刚十页分为十组，每组取每页最小值作为目录。
    2）mysql回表
        在InnoDB存储引擎下，二级索引查询到的索引列，如果需要查找所有列的数据，则需要到主键索引里面去取出数据。这个过程就称为回表。因为行的数据都是存在主键B+tree的叶子节点里面，
        二级索引的B+树叶子节点都是存放的(索引列,主键)。
2.mysql类型转换
  比如:
    1) select 'a'=1;  返回0 表示不相等
    2) select 'a'=0;  返回1 表示不相等   因为字符串(里面不是数字的字符串)会统统转换成0
    3) select '123'=123 返回1
3.只要查询时对字段做了操作就不会走索引
  比如:
    select *from t where a+1=1; 其中a是主键,但走不了索引

4.mysql分库分表
5.mysql mvcc
    mysql 在rr隔离级别下，根据mvcc原理，使用快照读 来解决幻读问题。
    快照读：mysql开启事务时，会返回当前事务id  然后每次查询时，只会返回事务id<=当前事务id的。 所以不会查到新开启事务提交后的内容
    当前读：各种update insert delete默认都是当前读，select for update也是当前读。
6.mysql事务隔离级别 及 可能产生的问题
    1）读未提交
        问题：脏读，读到对方未提交的数据，如果另一个事务回滚了，本事务的数据就有问题
    2）读已提交
        问题：不可重复读。虽然解决了脏读问题，但是会出现不可重复读问题，比如事务1先查询一条数据的内容，此时事务2改了这个内容并提交了，这时事务1再去查询，查到的结果和原先不一样了
    3）可重复读
        问题：幻读。
    4）可串行化
        一个事务一个事务执行，除了效率低，没有任何问题
7.


